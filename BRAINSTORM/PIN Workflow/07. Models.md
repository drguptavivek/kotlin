# MODELS
 - SQLAlchemy 2.0 model set (type-hinted `Mapped[...]`) 
 - PIN scoped only to `team_id`and a **role system that supports**:
    * **National admins** (all states/teams/supervisors)
    * **State admins** (one or more states → all teams & supervisors in those states)
    * **Team members** (scoped to a specific team)
    * **Supervisors** (scoped profile tied to a team)


```python
# models.py
from __future__ import annotations
import enum
import uuid
from datetime import datetime
from typing import List, Optional

import sqlalchemy as sa
from sqlalchemy import CheckConstraint, ForeignKey, UniqueConstraint, Index
from sqlalchemy.dialects.postgresql import UUID, INET
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


# ---------------- Base & naming ----------------
NAMING_CONVENTION = {
    "ix": "ix_%(table_name)s_%(column_0_N_name)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s",
}
class Base(DeclarativeBase):
    metadata = sa.MetaData(naming_convention=NAMING_CONVENTION)


# ---------------- Core reference ----------------
class STATE(Base):
    __tablename__ = "states"

    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    code: Mapped[str]     = mapped_column(sa.String(16), unique=True, nullable=False)
    name: Mapped[str]     = mapped_column(sa.String(128), unique=True, nullable=False)
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    teams:   Mapped[List[TEAM]]   = relationship(back_populates="state", cascade="all, delete-orphan")
    devices: Mapped[List[DEVICE]] = relationship(back_populates="state")

    def __repr__(self) -> str: return f"<STATE {self.code}>"


class TEAM(Base):
    __tablename__ = "teams"

    id: Mapped[uuid.UUID]     = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str]         = mapped_column(sa.String(128), unique=True, nullable=False)
    state_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("states.id", ondelete="RESTRICT"), nullable=False)
    timezone: Mapped[str]     = mapped_column(sa.String(64), nullable=False, default="Asia/Kolkata")
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    state: Mapped[STATE]      = relationship(back_populates="teams")
    devices: Mapped[List[DEVICE]] = relationship(back_populates="team")
    supervisors: Mapped[List[SUPERVISOR]] = relationship(back_populates="team", cascade="all, delete-orphan")
    pins: Mapped[List[PIN]]   = relationship(back_populates="team")

    __table_args__ = (
        Index("ix_teams_state_created", "state_id", sa.text("created_at DESC")),
    )

    def __repr__(self) -> str: return f"<TEAM {self.name}>"


# ---------------- Users & roles ----------------
class USER(Base):
    __tablename__ = "users"

    id: Mapped[uuid.UUID]  = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email: Mapped[str]     = mapped_column(sa.String(255), unique=True, nullable=False, index=True)
    full_name: Mapped[Optional[str]] = mapped_column(sa.String(255))
    is_active: Mapped[bool] = mapped_column(sa.Boolean, nullable=False, default=True)
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    roles: Mapped[List[USER_ROLE]] = relationship(back_populates="user", cascade="all, delete-orphan")
    supervisor_profile: Mapped[Optional[SUPERVISOR]] = relationship(back_populates="user", uselist=False)

    def __repr__(self) -> str: return f"<USER {self.email}>"


class ROLE(Base):
    """
    Use rows with names like:
      - 'national_admin'  (global scope: state_id NULL, team_id NULL)
      - 'state_admin'     (scoped by state_id)
      - 'team_member'     (scoped by team_id)
      - 'supervisor'      (scoped by team_id; profile in SUPERVISOR)
    """
    __tablename__ = "roles"

    id: Mapped[uuid.UUID]   = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name: Mapped[str]       = mapped_column(sa.String(64), unique=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(sa.Text)

    users: Mapped[List[USER_ROLE]] = relationship(back_populates="role", cascade="all, delete-orphan")

    def __repr__(self) -> str: return f"<ROLE {self.name}>"


class USER_ROLE(Base):
    """
    Role assignment with optional scope:
      - national_admin: state_id NULL, team_id NULL
      - state_admin:    state_id NOT NULL, team_id NULL
      - team_member:    state_id NULL, team_id NOT NULL
      - supervisor:     state_id NULL, team_id NOT NULL  (and SUPERVISOR row exists)
    NOTE: DB enforces *at most one* of (state_id, team_id). Per-role requirements enforced in application logic.
    """
    __tablename__ = "user_roles"

    id: Mapped[int] = mapped_column(sa.BigInteger, primary_key=True, autoincrement=True)

    user_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    role_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("roles.id", ondelete="RESTRICT"), nullable=False)

    # Optional scope
    state_id: Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("states.id", ondelete="CASCADE"))
    team_id:  Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("teams.id",  ondelete="CASCADE"))

    assigned_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    user: Mapped[USER] = relationship(back_populates="roles")
    role: Mapped[ROLE] = relationship(back_populates="users")
    state: Mapped[Optional[STATE]] = relationship()
    team:  Mapped[Optional[TEAM]]  = relationship()

    __table_args__ = (
        # Prevent dual-scope on one assignment
        CheckConstraint("(state_id IS NULL) OR (team_id IS NULL)", name="user_role_single_scope"),
        # Avoid duplicate assignments for same scope
        UniqueConstraint("user_id", "role_id", "state_id", "team_id", name="uq_user_role_user_role_scope"),
        Index("ix_user_roles_user", "user_id"),
        Index("ix_user_roles_role", "role_id"),
        Index("ix_user_roles_scope_state", "state_id"),
        Index("ix_user_roles_scope_team", "team_id"),
    )


# ---------------- Devices ----------------
class DEVICE(Base):
    __tablename__ = "devices"

    id: Mapped[uuid.UUID]       = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    android_id: Mapped[str]     = mapped_column(sa.String(128), unique=True, nullable=False, index=True)
    team_id: Mapped[uuid.UUID]  = mapped_column(ForeignKey("teams.id", ondelete="RESTRICT"), nullable=False)
    state_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("states.id", ondelete="RESTRICT"), nullable=False)  # denormalized for fast filtering
    tablet_name: Mapped[Optional[str]] = mapped_column(sa.String(128))
    last_seen_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
    last_seen_ip: Mapped[Optional[str]] = mapped_column(INET)
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    team:  Mapped[TEAM]  = relationship(back_populates="devices")
    state: Mapped[STATE] = relationship(back_populates="devices")

    __table_args__ = (
        Index("ix_devices_team_last_seen", "team_id", sa.text("last_seen_at DESC")),
        Index("ix_devices_state_last_seen", "state_id", sa.text("last_seen_at DESC")),
    )

    def __repr__(self) -> str: return f"<DEVICE {self.android_id[:8]}>"


# ---------------- Supervisor profile ----------------
class SUPERVISOR(Base):
    """
    One-to-one with USER, scoped to a TEAM (and by extension its STATE).
    Use USER_ROLE with role='supervisor' + team_id to grant permissions;
    this table keeps supervisor-specific fields.
    """
    __tablename__ = "supervisors"

    id: Mapped[uuid.UUID]   = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), unique=True, nullable=False)
    team_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("teams.id", ondelete="SET NULL"), nullable=True)

    phone: Mapped[Optional[str]] = mapped_column(sa.String(32))
    is_active: Mapped[bool] = mapped_column(sa.Boolean, nullable=False, default=True)
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    user: Mapped[USER] = relationship(back_populates="supervisor_profile")
    team: Mapped[Optional[TEAM]] = relationship(back_populates="supervisors")

    def __repr__(self) -> str: return f"<SUPERVISOR user={self.user_id} team={self.team_id}>"


# ---------------- PINs (scoped ONLY to team) ----------------
class PinKind(enum.IntEnum):
    TEAM_PIN = 0         # TP
    SUPERVISOR_PIN = 1   # SP (team-scoped bundle of SP verifiers for that team)

class PIN(Base):
    """
    Versioned PIN, scoped ONLY to team_id.
    Stores Argon2id verifier and AEAD-encrypted plaintext (for admin reveal).
    Devices never receive plaintext; admins can reveal via service + audit.
    """
    __tablename__ = "pins"

    id: Mapped[int] = mapped_column(sa.BigInteger, primary_key=True, autoincrement=True)

    team_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("teams.id", ondelete="CASCADE"), nullable=False)
    kind: Mapped[int]    = mapped_column(sa.SmallInteger, nullable=False)   # PinKind
    version: Mapped[int] = mapped_column(sa.Integer, nullable=False)        # monotonic per (team_id, kind)
    revoked: Mapped[bool]= mapped_column(sa.Boolean, nullable=False, default=False)

    # Verifier (Argon2id)
    kdf: Mapped[str]     = mapped_column(sa.String(16), nullable=False, default="argon2id")
    salt: Mapped[bytes]  = mapped_column(sa.LargeBinary, nullable=False)        # 16–32B
    mem_kib: Mapped[int] = mapped_column(sa.Integer, nullable=False)            # e.g., 65536
    iters: Mapped[int]   = mapped_column(sa.Integer, nullable=False)
    parallel: Mapped[int]= mapped_column(sa.Integer, nullable=False)
    verifier: Mapped[bytes] = mapped_column(sa.LargeBinary, nullable=False)     # Argon2id output

    # Encrypted plaintext (XChaCha20-Poly1305)
    ciphertext: Mapped[bytes] = mapped_column(sa.LargeBinary, nullable=False)
    aead_nonce: Mapped[bytes] = mapped_column(sa.LargeBinary, nullable=False)   # 24B
    aead_ad: Mapped[Optional[bytes]] = mapped_column(sa.LargeBinary)            # associated data (team_id, kind, version)

    created_by: Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("users.id", ondelete="SET NULL"))
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=False)

    team: Mapped[TEAM] = relationship(back_populates="pins")
    creator: Mapped[Optional[USER]] = relationship()

    __table_args__ = (
        UniqueConstraint("team_id", "kind", "version", name="uq_pins_team_kind_version", deferrable=True, initially="DEFERRED"),
        Index("ix_pins_team_kind_version", "team_id", "kind", sa.text("version DESC")),
        Index("ix_pins_revoked", "revoked"),
    )

    def __repr__(self) -> str:
        return f"<PIN {PinKind(self.kind).name} team={self.team_id} v{self.version} revoked={self.revoked}>"
```

### How this satisfies your scoping/roles

* **PIN** is **only** `team_id` scoped (no device scope).
* **National admins**: grant `ROLE.name='national_admin'` with a `USER_ROLE` row **without** `state_id`/`team_id`.
* **State admins**: grant `ROLE.name='state_admin'` with a `USER_ROLE` row where `state_id` is set (covers **all teams & supervisors** in that state).
* **Team members**: grant `ROLE.name='team_member'` with a `USER_ROLE` row where `team_id` is set.
* **Supervisors**: grant `ROLE.name='supervisor'` with a `USER_ROLE` scoped by `team_id` **and** keep supervisor-specific fields in `SUPERVISOR`.

If you want, I can add a small `PinService` (generate/reveal/revoke + version allocation per `(team_id, kind)`) and example role-check helpers (e.g., `can_manage_team(user, team_id)` with the national/state/team hierarchy).
